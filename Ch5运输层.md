viewport:width=device-width,initial-scale=1

目录

[TOC]

##计算机网络
###Ch5运输层

+ (在不可靠的网络上)实现可靠传输的工作原理
	- 停止-等待协议
	- ARQ
+ tcp报文段的首部格式
+ tcp的三个重要问题
	- 滑动窗口
	- 流量控制
	- 拥塞控制
+ tcp的连接管理

####运输层协议概述
#####进程间的通信

*有了网络层,为什么还要运输层,?*
通信真正的端点不是主机,而是主机中的进程

运输层一个很重要的功能-复用和分用

+ 复用:发送方不同的应用进程使用同一个运输层协议
+ 分用:接收方的运输层把数据正确交付目的应用进程
(ip层也有复用和分用..)


<!-- 网络层IP数据报只检验首部,而不检验数据部分 -->

**<u>运输层采用面向连接的tcp协议时,逻辑通信相当于一条全双工的可靠信道
采用无连接的upd协议时,逻辑信道仍然是一条不可靠信道</u>**
#####运输层的两个主要协议
+ udp:user datagram protocol
+ tcp: tansmission control protocol
#####运输层的端口
计算机中标识进程用pid
网络中标识进程用端口号
(运输层数据报交付到端口,再有端口交付到目的进程)

+ 服务器端使用的端口号
	- 熟知端口号(0-1023)
	- 登记端口号(1024-49152)
+ 客户端使用的端口号(49152-65535)
####用户数据报UDP
+ 特点
	- 无连接
	- 尽最大努力交付
	- 面向报文:原样发送应用层交付的报文,不合并,不拆分
	- 没有拥塞控制
		+ 有可能引起网络严重的拥塞问题
	- 支持一对一,一对多,多对一,多对多的交互通信
	- 首部开销小,$8个B=4字段\times 2B/字段$
+ 首部格式:4个字段,每个字段2个字节
	- 源端口
	- 目的端口
	- 长度
	- 校验和:要增加12B的伪首部然后计算
		+ 二进制反码运算求和,,??
####传输控制协议TCP
+ 主要特点
	- 面向连接
	- 只能一对一
	- 可靠交付
	- 全双工通信
	- 面向字节流(流入到进程/从进程流出的字节序列)
	而不是面向数据块
		+ 虽然应用程序和tcp的交互是一次一个数据块
		但面向的是这些数据块组成的字节流
		- 和udp相比,tcp不关心应用进程一次把多长的报文发送到tcp的缓存中
		而是根据对方给出的窗口值和当前网络拥塞的程度,来决定一个报文段应包含多少个字节
			+ upd是给多少发多少,不拆分
			+ tcp中,应用进程发的多可以划分为短报文再传送;
			应用进程发来的少,可以先攒着
+ tcp的连接
	- $套接字 socket=\{IP:port\}$
	- $tcp连接::=\{socket_1,socket_2\}=\{IP_1:port_1,IP_2:port_2\}$

####TCP报文段的首部格式
![tcp报文格式][0]

+ 序号/报文段序号:4B
**<u>本报文段发送的数据的第一个字节(在整个字节流中)的序号</u>**
+ 确认号:4B
**<u>期望收到对方下一个报文段的第一个数据字节的序号
同时也是对之前序号的确认,即</u>**
	- $若确认号为N,则表明:到序号N-1为止的所有数据都以正确收到$
+ 数据偏移:4bit
**<u>报文段数据起始处 距离 tcp报文段的起始处有多远
也就是tcp报文段首部长度
以4B 为单位</u>**
	- 4bit偏移,最大表示15,以4B为单位,表示60B
	tcp选项长度不超过40B
+ 保留	
+ 控制位
	- 紧急URG
		+ URG=1时,表明紧急指针有效
		+ 紧急指针,2B,本报文段中的紧急数据的长度(字节数)
		(紧急数据放在报文数据段的开头,所以给出了长度,就能确定紧急数据都有哪些)
		+ 功能:接收方看到tcp报文中有紧急数据,就会优先处理这个含有紧急数据的tcp报文
		(放在tcp接收缓存的头部,而不是按接收顺序存放)
	- 确认ACK
		+ ACk=1时,确认号字段才有效
		(tcp连接建立后,所有传送的报文段的ack都要置1)
	- 推送PSH
		+ 功能:接收方看到tcp报文中有`推送push`标志,金尽快地交付给应用进程
		而不再等到整个缓存都填满了后再向上交付
	- 复位RST
		+ RST=1时,表明tcp连接出现严重错误,必须释放连接,然后重新建立
		还用来拒绝一个非法的报文段或拒绝打开一个连接
	- 同步SYN
		+ SYN=1&ACK=0时,表明这是一个连接请求报文段
		若对方同意建立连接,则在响应报文段中使SYN=1&ACK=1
		所以$SYN=1,表明这是一个连接请求 或 连接接受报文$
	- 终止FIN
		+ FIN=1时,表明此报文段的发送方的数据已发送完毕,要求释放运输连接
		+ 用来释放一个连接
+ 窗口:2B
	- **<u>发送本报文段的一方的接收窗口</u>
	用来告诉对方:自己允许对方发送的(也就是 自己能够接收的) 数据量**
		+ 这个值是自己的接收窗口的容量
		确认号给出了接收窗口的最小值
		窗口值与确认号之和是发送这个报文的tcp进程的接收窗口的最大值
	- **<u>指明了现在允许对方发送的数据量</u>**
+ 校验和:2B,要加上伪首部
+ 紧急指针
+ 选项
	- MSS:最大报文段长度(数据字段的最大长度)
	- 窗口扩大
	- 时间戳
		+ 用来计算RTT
		+ 用于处理TCP序号超过$2^{32}$的情况,防止序号回绕
	- 选择确认:自己接收到的不连续块的边界信息
####可靠传输的工作原理+TCP可靠传输的实现

ARQ(automatic repeat request,自动重复请求)协议

#####停止等待协议(确认+重传):
**每发送一个分组就停止发送,等待对方的确认,收到对方的确认后再发送下一个分组**

1. 无差错的情况
2. 超时重传:
	+ 接收方收到的报文有差错于是丢弃,
	发送方收不到确认报文,等待时间超时后,就重新发送报文
		- 发送方要暂时保留已发送报文副本,以备重传
		- 分组和确认分组要编号(发送分组1,则等待确认报文0)
		- 超时时间应比RTT更长一些
			+ 比rtt短的话,确认报文还没到就重传了
			+ 比RTT长太多,效率太低
3. 确认丢失:
	+ 接收方的确认报文丢失了
	发送方收不到确认报文,超时重传要发送的报文
		- 这时接收方再次收到了报文,应采取两个行动
			+ 丢弃重传来的报文
			+ 向发送方再次发送确认
4. 确认迟到
	+ 接收方的确认报文迟到了
	发送方收不到确认报文,超时重传要发送的报文
		- 这时接收方再次收到了报文,应采取两个行动
			+ 丢弃重传来的报文
			+ 向发送方再次发送确认
		- 接收方最开始的报文到达了发送方,发送方应该
			+ 丢弃掉
	- 最终发送方总能收到确认报文

#####信道利用率的问题
一次停止等待是一个发送周期
时间分析	

+ $发送分组需要的时间T_D = \frac{分组长度}{数据率}$
+ $分组到达接收方, \frac{1}{2}RTT$
+ $接收方处理分组,(忽略不计)$
+ $接收方发送确认分组的时间T_A= \frac{确认分组长度}{数据率}$
+ $确认分组达到发送方, \frac{1}{2}RTT$
+ $发送方收到确认分组后处理,(忽略不计)$
+ $发送一次分组用时T_D+RTT+T_A\\\
用来传送有用数据的时间T_D\\\
信道利用率U = \frac{T_D}{T_D+RTT+T_A}$

#####连续ARQ协议
+ 回退N帧,累积确认
+ 选择重传

#####TCP可靠传输的实现
讨论A向B发送数据
A的发送窗口,B的接收窗口
######以字节为单位的滑动窗口

+ A的发送窗口:表示在没有收到B的确认的情况下,A可以连续把窗口内的数据都发送出去
	- 后沿:已发送且收到了确认
		+ 不动:没有收到新的确认
		+ 前移:收到了新的确认
	- 前沿:不允许发送,(因为接收方没有足够的缓存空间存放这部分数据)
		+ 前移	
		+ 不动:
			- 没有收到新的确认,对方通知的窗口大小也不变
			- 收到了新的确认,(前沿本该前移),但是对方通知的窗口缩小了,恰好维持不动
		+ 向后收缩:对方通知窗口缩小了
	- 可用窗口/有效窗口:窗口中允许但未发送的字节数
+ 窗口和缓存的关系
	- 发送数据的应用程序向它的发送缓存不断写入数据到缓存队列尾部
		+ 发送窗口从缓存队列头部开始发送数据
		+ 发送缓存中暂时存放
			- 准备发送的数据
			- 已发送但未收到确认的数据
	- 接收数据的应用程序从它的接收缓存队列的头部读取数据
		+ 接收窗口的
			- 前沿是按序入队的字节后的一个位置	
			- 后沿是接收缓存队列空间的尾部
		+ 接收缓存中暂时存放
			- 按序到达但尚未被接收应用程序读取的数据
			- 未按序到达的数据
+ 发送窗口受接收窗口调节
	- 由于传输有延迟,调节也有延迟
+ 关于不按序到达的数据如何处理
	- TCP通常都是先临时存放在接收窗口中
+ 累积确认,捎带确认				

######超时重传时间的选择
+ $加权平均往返RTT_s$
+ $RTT_D$
+ ...
+ 只要报文重传了,就不采用其往返时间样本
######选择确认SACK
+ 指明SACK选项
+ 指明这个选项占用多少字节
+ 不连续字节快的边界信息
####TCP的流量控制
流量控制:让发送方的发送速率不要太快,要让接收方来得及接收
**<u>利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制</u>**

rwnd receive window
接收方通过调整窗口值

**零窗口报文段丢失引起的死锁局面
(发送方在等待接收方发来的窗口非零通知,接收方再等待发送方发来数据)
<u>设置一个持续计数器</u>**
只要TCP连接的一方收到对方的零窗口通知,就启动持续计数器
时间一到,就主动发送一个零窗口探测报文
(TCP规定,即使设置为零窗口,也必须接收
零窗口探测报文,确认报文,携带紧急数据的报文)
对方在对这个报文的确认报文中给出它的窗口值

+ 如果还是零,就重置持续计数器
+ 如果不是零,死锁僵局自然打破

**传输效率,tcp报文段的发送时机**

+ 缓存中存放的数据达到MSS字节时,就组装成一个tcp报文段发送出去
+ 发送方要求push报文
+ 当计数器期限到了,就发送

**nagle 算法**
,,,

*糊涂窗口综合征*

>发送方不发送很小的报文段,接收方也不会在缓存刚刚有了一点小的空间
就急忙把这个很小的窗口大小信息通知给对方

####TCP的拥塞控制
#####拥塞控制的一般原理
拥塞控制:防止过度的数据注入到网络中,这样可以使网络中的路由器或链路不致过载

拥塞控制是一个全局性的过程
流量控制是点对点通信量的控制


动态问题
控制理论
开环控制
闭环控制
,,
#####几种拥塞控制方法
在不受接收方缓存大小限制的情况下,
发送方维持一个拥塞窗口的状态变量,其大小取决于网络的拥塞程度
发送方让自己的发送窗口等于拥塞窗口


1. 慢开始:**cwnd指数增长**
	+ 主机开始发送数据时,不是立即把大量数据注入到网络
	而是先探测一下,`由小到大的增大发送窗口`
	+ 每经过一个传输轮次,拥塞窗口`cwnd就加倍`
	+ 慢开始门限ssthresh
		- 初始值为16MSS
		- 当cwnd > ssthresh时,改用拥塞避免算法
2. 拥塞避免:**cwnd加法增大**
在拥塞避免阶段将拥塞窗口控制为按线性规律增长,<u>使网络比较不容易出现拥塞</u>
	+ 每经过一个RTT,`cwnd加1`,(以MSS为单位)
3. 	只要发送方判断出网络出现拥塞,就把ssthresh设置为出现拥塞时cwnd的一半
然后,重新这只cwnd为1MSS
4. 快重传
	+ 接收方收到失序报文段时,应及时发送对 按序接收的最大序号报文 的重复确认
	+ 发送方只要`一连收到三个重复确认就可以判断对方收到了失序报文
	应当立即重传 ,而不是 等待确认`
5. 快恢复
	+ 发送方只要`一连收到三个重复确认`,就把ssthresh减半
	这是为了预防网络发生拥塞
	+ cwnd=ssthresh,而不是置1
	然后`拥塞避免`


$$发送方窗口的上限值 = Min[rwnd,cwnd]$$

+ $当rwnd接收窗口< cwnd拥塞窗口,
是 接收方的接收能力 限制发送方窗口的最大值$
+ $当rwnd接收窗口> cwnd拥塞窗口,
是 网络的拥塞 限制发送方窗口的最大值$
#####随机早期检测
####TCP的运输连接管理
#####连接建立,3次握手

+ $客户端\overset{SYN=1,seq=x}\longrightarrow 服务器$
	- 客户端进入SYN-SENT(同步已发送)状态
+ $客户端\overset{SYN=1,ACK=1,seq=y,ack=x+1}\longleftarrow服务器$
	- 服务器进入SYN-RCVD(同步收到)状态
	- $SYN报文段不能携带数据,但要消耗一个序号$
+ $客户端\overset{ACK=1,seq=x+1,ack=y+1}\longrightarrow 服务器$
	- 客户端和服务器进入ESTABLISHED(连接已建立)状态
	- $ACK报文段如果不携带数据,则不消耗序号$
		+ 也就是说,这种情况下,
		客户端发送的下一个数据报文段的序号仍然是x+1

**第三次握手,客户端要向服务器发送一次确认
<u>是为了防止已失效的连接请求报文段和服务器建立起连接</u>**

+ 可以这么理解,tcp连接是全双工连接,即
	- 客户端要向服务器请求建立连接
		+ 客户端发SYN,服务器回复ACK
	- 服务器也要向客户端请求建立连接
		+ 服务器发SYN,客户端回ACK
	- 只有双向连接都建立起来,整个tcp连接才能建立
	第三次握手是客户端对服务器请求建立连接的确认(ACK)
		+ 如果只有一个方向的连接
	- 同时,服务器在确认客户端时,捎带上了自己的SYN
	所以,双向连接建立用了三次握手

|$\longrightarrow\\\ \swarrow\\\ \longleftarrow\\\ \searrow$|$\longrightarrow\\\ \swarrow\\\ \searrow$|
|-|-|	

#####连接释放,4次握手(理想情况)
FIN报文即使不携带数据,也要消耗掉一个序号

此处,是客户端主动关闭连接,先发出连接释放报文

+ 客户端向服务器发送连接释放报文
$客户端\overset{FIN=1,seq=u}\longrightarrow 服务器\\\
客户端发送了连接释放报文后,进入了FIN-WAIT-1(终止等待1)状态$
+ 服务器向客户端发出确认
$客户端\overset{ACK=1,seq=v,ack=u+1}\longleftarrow 服务器\\\
服务器发送了确认后,进入CLOSE-WAIT(关闭等待)状态$
	- 从客户端到服务器这个方向的连接释放了,tcp连接处于半关闭状态
	从服务器到客户端这个方向的连接并未关闭
+ $客户端收到来自服务器的确认后,进入FIN-WAIT-2(终止等待2)状态\\\
等待服务器发送连接释放报文$
+ 服务器向客户端发送连接释放报文
$客户端\overset{FIN=1,seq=w,ack=u+1}\longleftarrow服务器\\\
服务器要重复上次已发送过的确认号ack=u+1\\\
服务器发送了请求释放报文后进入了LAST-ACK(最后确认)状态\\\
等待客户端的确认报文$
+ 客户端收到服务器发来的请求释放报文后,对此发出确认
$客户端\overset{FIN=1,seq=u+1,ack=w+1}\longrightarrow 服务器\\\
客户端发送了确认报文后进入TIME-WAIT(时间等待)状态$
	- 服务器收到客户端的确认报文后进入了CLOSED(关闭)状态
+ 经过时间等待计时器设置的时间2MSL后,客户端进入关闭状态
	- MSL(Maximum Segment Lifetime)最长报文段寿命
	- 为什么要有TIME-WAIT状态
	(而不是主动关闭连接一方向另一方发出确认后立即进入关闭状态)?
		+ 保证发送的这个确认能够到达另一方
		(通过等待足够长的时间)
			- 发送最后的确认的一方等待2MSL的时间,
			在这段时间里如果另一方由于没收到确认报文而向`客户端...`重传连接释放报文
			客户端就重发确认报文,重新进入一个新的2MSL等待周期内
		+ 防止防止`已失效的连接请求报文段`出现在本连接中
		通过等2MSL的时间,使本连接持续时间内所产生的所有报文段都从网络中消失
+ 保活计时器解决通信一方突然出现故障,连接断开的问题
	- 每收到一次数据,就重置保活计时器		



[0]:http://cjhgo.sinaapp.com/CS/ComputerNetwork/images/TCPprotocol.gif