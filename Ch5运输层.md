viewport:width=device-width,initial-scale=1

目录

[TOC]

##计算机网络
###Ch5运输层

+ (在不可靠的网络上)实现可靠传输的工作原理
	- 停止-等待协议
	- ARQ
+ tcp报文段的首部格式
+ tcp的三个重要问题
	- 滑动窗口
	- 流量控制
	- 拥塞控制
+ tcp的连接管理

####运输层协议概述
#####进程间的通信

*有了网络层,为什么还要运输层,?*
通信真正的端点不是主机,而是主机中的进程

运输层一个很重要的功能-复用和分用

+ 复用:发送方不同的应用进程使用同一个运输层协议
+ 分用:接收方的运输层把数据正确交付目的应用进程
(ip层也有复用和分用..)


<!-- 网络层IP数据报只检验首部,而不检验数据部分 -->

**<u>运输层采用面向连接的tcp协议时,逻辑通信相当于一条全双工的可靠信道
采用无连接的upd协议时,逻辑信道仍然是一条不可靠信道</u>**
#####运输层的两个主要协议
+ udp:user datagram protocol
+ tcp: tansmission control protocol
#####运输层的端口
计算机中标识进程用pid
网络中标识进程用端口号
(运输层数据报交付到端口,再有端口交付到目的进程)

+ 服务器端使用的端口号
	- 熟知端口号(0-1023)
	- 登记端口号(1024-49152)
+ 客户端使用的端口号(49152-65535)
####用户数据报UDP
+ 特点
	- 无连接
	- 尽最大努力交付
	- 面向报文:原样发送应用层交付的报文,不合并,不拆分
	- 没有拥塞控制
		+ 有可能引起网络严重的拥塞问题
	- 支持一对一,一对多,多对一,多对多的交互通信
	- 首部开销小,$8个B=4字段\times 2B/字段$
+ 首部格式:4个字段,每个字段2个字节
	- 源端口
	- 目的端口
	- 长度
	- 校验和:要增加12B的伪首部然后计算
		+ 二进制反码运算求和,,??
####传输控制协议TCP
+ 主要特点
	- 面向连接
	- 只能一对一
	- 可靠交付
	- 全双工通信
	- 面向字节流(流入到进程/从进程流出的字节序列)
	而不是面向数据块
		+ 虽然应用程序和tcp的交互是一次一个数据块
		但面向的是这些数据块组成的字节流
		- 和udp相比,tcp不关心应用进程一次把多长的报文发送到tcp的缓存中
		而是根据对方给出的窗口值和当前网络拥塞的程度,来决定一个报文段应包含多少个字节
			+ upd是给多少发多少,不拆分
			+ tcp中,应用进程发的多可以划分为短报文再传送;
			应用进程发来的少,可以先攒着
+ tcp的连接
	- $套接字 socket=\{IP:port\}$
	- $tcp连接::=\{socket_1,socket_2\}=\{IP_1:port_1,IP_2:port_2\}$

####TCP报文段的首部格式
![tcp报文格式][0]

+ 序号/报文段序号:4B
**<u>本报文段发送的数据的第一个字节(在整个字节流中)的序号</u>**
+ 确认号:4B
**<u>期望收到对方下一个报文段的第一个数据字节的序号
同时也是对之前序号的确认,即</u>**
	- $若确认号为N,则表明:到序号N-1为止的所有数据都以正确收到$
+ 数据偏移:4bit
**<u>报文段数据起始处 距离 tcp报文段的起始处有多远
也就是tcp报文段首部长度
以4B 为单位</u>**
	- 4bit偏移,最大表示15,以4B为单位,表示60B
	tcp选项长度不超过40B
+ 保留	
+ 控制位
	- 紧急URG
		+ URG=1时,表明紧急指针有效
		+ 紧急指针,2B,本报文段中的紧急数据的长度(字节数)
		(紧急数据放在报文数据段的开头,所以给出了长度,就能确定紧急数据都有哪些)
		+ 功能:接收方看到tcp报文中有紧急数据,就会优先处理这个含有紧急数据的tcp报文
		(放在tcp接收缓存的头部,而不是按接收顺序存放)
	- 确认ACK
		+ ACk=1时,确认号字段才有效
		(tcp连接建立后,所有传送的报文段的ack都要置1)
	- 推送PSH
		+ 功能:接收方看到tcp报文中有`推送push`标志,金尽快地交付给应用进程
		而不再等到整个缓存都填满了后再向上交付
	- 复位RST
		+ RST=1时,表明tcp连接出现严重错误,必须释放连接,然后重新建立
		还用来拒绝一个非法的报文段或拒绝打开一个连接
	- 同步SYN
		+ SYN=1&ACK=0时,表明这是一个连接请求报文段
		若对方同意建立连接,则在响应报文段中使SYN=1&ACK=1
		所以$SYN=1,表明这是一个连接请求 或 连接接受报文$
	- 终止FIN
		+ FIN=1时,表明此报文段的发送方的数据已发送完毕,要求释放运输连接
		+ 用来释放一个连接
+ 窗口:2B
	- **<u>发送本报文段的一方的接收窗口</u>
	用来告诉对方:自己允许对方发送的(也就是 自己能够接收的) 数据量**
		+ 这个值是自己的接收窗口的容量
		确认号给出了接收窗口的最小值
		窗口值与确认号之和是发送这个报文的tcp进程的接收窗口的最大值
	- **<u>指明了现在允许对方发送的数据量</u>**
+ 校验和:2B,要加上伪首部
+ 紧急指针
+ 选项
	- MSS:最大报文段长度(数据字段的最大长度)
	- 窗口扩大
	- 时间戳
		+ 用来计算RTT
		+ 用于处理TCP序号超过$2^{32}$的情况,防止序号回绕
	- 选择确认:自己接收到的不连续块的边界信息
####可靠传输的工作原理+TCP可靠传输的实现

ARQ(automatic repeat request,自动重复请求)协议

#####停止等待协议(确认+重传):
**每发送一个分组就停止发送,等待对方的确认,收到对方的确认后再发送下一个分组**

1. 无差错的情况
2. 超时重传:
	+ 接收方收到的报文有差错于是丢弃,
	发送方收不到确认报文,等待时间超时后,就重新发送报文
		- 发送方要暂时保留已发送报文副本,以备重传
		- 分组和确认分组要编号(发送分组1,则等待确认报文0)
		- 超时时间应比RTT更长一些
			+ 比rtt短的话,确认报文还没到就重传了
			+ 比RTT长太多,效率太低
3. 确认丢失:
	+ 接收方的确认报文丢失了
	发送方收不到确认报文,超时重传要发送的报文
		- 这时接收方再次收到了报文,应采取两个行动
			+ 丢弃重传来的报文
			+ 向发送方再次发送确认
4. 确认迟到
	+ 接收方的确认报文迟到了
	发送方收不到确认报文,超时重传要发送的报文
		- 这时接收方再次收到了报文,应采取两个行动
			+ 丢弃重传来的报文
			+ 向发送方再次发送确认
		- 接收方最开始的报文到达了发送方,发送方应该
			+ 丢弃掉
	- 最终发送方总能收到确认报文

#####信道利用率的问题
一次停止等待是一个发送周期
时间分析	

+ $发送分组需要的时间T_D = \frac{分组长度}{数据率}$
+ $分组到达接收方, \frac{1}{2}RTT$
+ $接收方处理分组,(忽略不计)$
+ $接收方发送确认分组的时间T_A= \frac{确认分组长度}{数据率}$
+ $确认分组达到发送方, \frac{1}{2}RTT$
+ $发送方收到确认分组后处理,(忽略不计)$
+ $发送一次分组用时T_D+RTT+T_A\\\
用来传送有用数据的时间T_D\\\
信道利用率U = \frac{T_D}{T_D+RTT+T_A}$

#####连续ARQ协议
+ 回退N帧,累积确认
+ 选择重传

#####TCP可靠传输的实现

####TCP的拥塞控制
####TCP的运输连接管理
#####连接建立,3次握手

+ $客户端\overset{SYN=1,seq=x}\longrightarrow 服务器$
	- 客户端进入SYN-SENT(同步已发送)状态
+ $客户端\overset{SYN=1,ACK=1,seq=y,ack=x+1}\longleftarrow服务器$
	- 服务器进入SYN-RCVD(同步收到)状态
	- $SYN报文段不能携带数据,但要消耗一个序号$
+ $客户端\overset{ACK=1,seq=x+1,ack=y+1}\longrightarrow 服务器$
	- 客户端和服务器进入ESTABLISHED(连接已建立)状态
	- $ACK报文段如果不携带数据,则不消耗序号$
		+ 也就是说,这种情况下,
		客户端发送的下一个数据报文段的序号仍然是x+1

**第三次握手,客户端要向服务器发送一次确认
<u>是为了防止已失效的连接请求报文段和服务器建立起连接</u>**

+ 可以这么理解,tcp连接是全双工连接,即
	- 客户端要向服务器请求建立连接
		+ 客户端发SYN,服务器回复ACK
	- 服务器也要向客户端请求建立连接
		+ 服务器发SYN,客户端回ACK
	- 只有双向连接都建立起来,整个tcp连接才能建立
	第三次握手是客户端对服务器请求建立连接的确认(ACK)
		+ 如果只有一个方向的连接
	- 同时,服务器在确认客户端时,捎带上了自己的SYN
	所以,双向连接建立用了三次握手

|$\longrightarrow\\\ \swarrow\\\ \longleftarrow\\\ \searrow$|$\longrightarrow\\\ \swarrow\\\ \searrow$|
|-|-|	

#####连接释放,4次握手(理想情况)
FIN报文即使不携带数据,也要消耗掉一个序号

此处,是客户端主动关闭连接,先发出连接释放报文

+ 客户端向服务器发送连接释放报文
$客户端\overset{FIN=1,seq=u}\longrightarrow 服务器\\\
客户端发送了连接释放报文后,进入了FIN-WAIT-1(终止等待1)状态$
+ 服务器向客户端发出确认
$客户端\overset{ACK=1,seq=v,ack=u+1}\longleftarrow 服务器\\\
服务器发送了确认后,进入CLOSE-WAIT(关闭等待)状态$
	- 从客户端到服务器这个方向的连接释放了,tcp连接处于半关闭状态
	从服务器到客户端这个方向的连接并未关闭
+ $客户端收到来自服务器的确认后,进入FIN-WAIT-2(终止等待2)状态\\\
等待服务器发送连接释放报文$
+ 服务器向客户端发送连接释放报文
$客户端\overset{FIN=1,seq=w,ack=u+1}\longleftarrow服务器\\\
服务器要重复上次已发送过的确认号ack=u+1\\\
服务器发送了请求释放报文后进入了LAST-ACK(最后确认)状态\\\
等待客户端的确认报文$
+ 客户端收到服务器发来的请求释放报文后,对此发出确认
$客户端\overset{FIN=1,seq=u+1,ack=w+1}\longrightarrow 服务器\\\
客户端发送了确认报文后进入TIME-WAIT(时间等待)状态$
	- 服务器收到客户端的确认报文后进入了CLOSED(关闭)状态
+ 经过时间等待计时器设置的时间2MSL后,客户端进入关闭状态
	- MSL(Maximum Segment Lifetime)最长报文段寿命
	- 为什么要有TIME-WAIT状态
	(而不是主动关闭连接一方向另一方发出确认后立即进入关闭状态)?
		+ 保证发送的这个确认能够到达另一方
		(通过等待足够长的时间)
			- 发送最后的确认的一方等待2MSL的时间,
			在这段时间里如果另一方由于没收到确认报文而向`客户端...`重传连接释放报文
			客户端就重发确认报文,重新进入一个新的2MSL等待周期内
		+ 防止防止`已失效的连接请求报文段`出现在本连接中
		通过等2MSL的时间,使本连接持续时间内所产生的所有报文段都从网络中消失
+ 保活计时器解决通信一方突然出现故障,连接断开的问题
	- 每收到一次数据,就重置保活计时器		



[0]:http://cjhgo.sinaapp.com/CS/ComputerNetwork/images/TCPprotocol.gif