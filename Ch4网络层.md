viewport:width=device-width,initial-scale=1

目录

[TOC]

##计算机网络
###Ch4网络层
网络互连:多个网络通过路由器互连成为一个互联网络

介绍网络层提供的两种不同服务->网际协议IP->网际控制报文协议ICMP和几种常用的路由选择协议,IP多播
->虚拟专用网VPN,网络地址转换NAT

传统的分类IP地址&无分类域间路由选择CIDR
路由选择协议的工作原理

####1.网络层提供的两种服务:面向连接&无连接
网络层应该向运输层提供怎样的服务
面向连接还是无连接,?

+ 面向连接的虚电路服务
+ 无连接的数据报服务

**在计算机通信中,<u>可靠交付</u>应当由谁来负责**

因特网的设计思路:
**网络层向上只提供简单灵活的,无连接的,尽最大努力交付的数据报服务**

+ 不建立连接,每一个IP分组独立发送,与其前后分组无关(不进行编号)
+ 网络层不提供服务质量承诺
	- 分组可能出错,丢失,失序

####2.网际协议IP
与IP协议配套使用的三个协议

+ 地址解析协议ARP(Address Resolution Protocol)	
+ 网际控制报文协议ICMP(Internet Control Message Protocol)
+ 网际组管理协议IGMP(Internet Group Management Protocol )

网际协议IP及其配套协议
![网际协议IP及其配套协议][0]

#####虚拟互连网络

网络互相连接遇到的问题

+ 不同的寻址方案
+ 不同的最大分组长度
+ 不同的网络接入机制
+ 不同的超时控制
+ 不同的差错恢复方法
+ 不同的状态报告方法
+ 不同的路由选择技术
+ 不同的用户接入控制
+ 不同的服务:面向连接,无连接
+ 不同的管理与控制方式


将网络互相连接起来要使用一些**中间设备**

+ 物理层使用的中间设备叫做<u>转发器repeater</u>
+ 数据链路层使用的中间设备叫做<u>网桥/桥接器</u>
+ 网络层使用的中间设备叫做<u>路由器</u>
+ 网络层以上使用的中间设备叫做<u>网关(gateway)</u>

异构网络通过路由器互连,

虚拟网络上如何寻址

#####分类的IP地址
IP地址给每个连接在因特网上的主机分配一个在全世界范围是唯一的32位标识符

$$IP地址::={<网络号>,<主机号>}$$
分类的IP地址
![分类的IP地址][1]

+ $A类,B类,C类地址的网络号字段分别为1,2,3字节;规定的数值位叫做$<u>**类别位**</u>
+ $A类,B类,C类地址的主机号字段分别为3,2,1字节$
+ D类地址用于多播(一对多通信)
+ E类地址保留

**点分十进制**
32位的IP地址,8位一组,组间加点,每组用十进制表示

常用的三类IP地址

- $A类地址$
	+ $A类地址的网络号占一个字节,只有7位可用,可指派的网络号是126=2^7-2个$
		- 为什么要减2
			+ $网络号字段全0的IP地址是保留地址,意思是$**本网络**
				- $网络号00000000_2$不可指派
			+ $网络号字段为127保留为本地软件环回测试(loopback$ $test)$本主机的进程之间通信之用
				- $网络号01111111_2$不可指派
	+ $A类地址主机号占3个字节,每一个A类网络中的最大主机数是16777214=2^{24}-2$
		- 为什么要减2
			+ $全0的主机号字段表示该IP地址是本主机所连接到的$**单个网络地址**
				- $主机号0.0.0$不可指派
				- $主机IP地址为5.6.7.8,则该主机所在的网络地址就是5.0.0.0$
			+ 全1的主机号字段表示该网络上的所有主机
				- $主机号255.255.255$不可指派
- $B类地址$
	+ $B类地址的网络号占两个字节,只有14位可用,可指派的网络号是16383=2^{14}-1个$
		- 为什么减1
			+ $网络号10000000.00000000/128.0不指派,从128.1$开始指派
	+ $B类地址主机号占两个字节,每一个B类网络中的最大主机数是65534=2^{16}-2$
		- 为什么减2
			+ 扣除主机号全0和全1的情况
- $C类地址$
	+ $C类地址的网络号占三个字节,有21位可用,可指派的网络号是2^{21}-1个$
		- 为什么减1
			+ $网络号11000000.00000000.00000000/192.0.0不指派,从192.0.1$开始指派
	+ $C类地址主机号占一个字节,每一个C类网络中的最大主机数是254=2^8-2$
		- 为什么减2
			+ 扣除主机号全0和全1的情况

总结两点

+ **网络号,可用字段为全0的都不分派**,
所以A,B,C每一类网络号数目减一
	- 网络号可用位全0表示本网络
	- 网络号为127的IP地址保留为本地环回地址,
	所以A类网络号数目再减一
+ **主机号,字段全0和全1都不分派**
所以,A,B,C每一类主机号数目减2
	- 字段全0用于表示网络地址
	- 字段全1用于表示所有主机

$IP128.7.255.255::={<128.7>,<255.255>},主机号为全1,表示网络128.7.0.0上的所有主机$
$IP0.0.0.35::={<0>,<0.0.35>}网络号可用位全0,表示这个网络上主机号位35的主机$

IP地址重要特点

+ IP地址由网络号和主机号两部分组成,是一种分等级的地址机构
	- IP地址管理机构只分配网络号
	- 路由器仅根据目的主机的网络号转发分组
	减小了路由表所占的存储空间及路由表查找时间
+ IP地址实际上标志一个主机和一条链路的接口
	- 当一个主机同时连接到两个网络上时,各自都要一个IP地址来标志.多归属主机
	比如路由器	
+ 一个网络是指具有相同网路号net-id的主机的集合
	- 因此用转发器/网桥连接起来的若干个局域网仍是一个网络
+ 所有分配到网路号的网络是平等地

**当两个路由器直连时**在连接线的两端的接口处,可以分配也可以不分配IP地址

+ 分配了IP地址,这一段连线就构成了一种只包含一段线路的特殊网络
+ 不分配也可以,无编号网络/无名网络

#####IP地址与硬件地址

在网络层,IP数据报的目的地址和源地址始终不变
在数据链路层,MAC帧在不同网络上传送时首部中的目的地址和源地址要发生变化

#####地址解析协议ARP
ARP:已知IP地址,找到相应的硬件地址
从网络层使用的IP地址解析出数据链路层使用的硬件地址

**由于传送ARP分组使用的是IP协议,**所以ARP协议属于网络层

(RARP的功能包含在了DHCP中)

ARP协议的要点

在主机的ARP高数缓存中存放一个从IP地址到硬件地址的映射表.
(映射表经常动态更新)

主机A向主机B发送IP数据报时,如果主机A的ARP高速缓存中没有主机B的数据
主机A自动运行ARP

+ ARP进程在本局域网上广播发送一个ARP请求分组
	- 内容是:我的IP地址,硬件地址,想知道的硬件地址对应的IP地址
+ 本局域网上的所有主机运行的ARP进程收到了此ARP请求方分组
+ 主机B的IP地址与ARP请求查询的一致,收下了此分组,开始响应
+ 主机A收到主机B的ARP响应分组后,在自己的ARP高速缓存中写入数据	

如果没有ARP高速缓存,主机每一次通信都要通过广播方式获得硬件地址,无疑很低效

ARP为映射地址项目都设置一个生存时间

ARP解析解决一个局域网内IP地址到硬件地址的映射问题

从IP地址到硬件地址的解析式自动进行的,主机用户对地址解析过程是不知道的

使用ARP的四种典型情况

+ 局域网内一个主机H1发往同一个局域网内另一个主机H2
+ 主机H1发往另一个局域网H2
+ 路由器发送到局域网内的一个主机
+ 路由器发送到另一个局域网内的一个主机

(为什么不直接使用硬件地址,?
使用抽象的IP地址是为了隐蔽底层网络的复杂性)
#####IP数据报的格式
![IPpacket][2]
$IP数据报=首部+数据部分\\\
首部=20字节固定长度+可变部分\\\
可变部分=可选字段+填充$

+ 固定部分字段
	- **版本**:IPV4/IPV6
	- **首部长度**:固定部分+可变部分的长度,以4字节为单位
		+ $首部至少有20字节,所以首部长度最小值是5(0101_2)\times 4Byte\\\
		占用4位,最大值是15(1111_2),对应首部长为60Byte$
			- 显然如果首部长度用4位二级制数指明,则对应的长度必须为4Byte的倍数
			如果不满足这个条件,就要用填充字段加以填充
	- 区分服务:一般不使用
	- **总长度**:首部和数据之和的长度,单位字节
		+ $总长度字段占用16位,则IP数据报的最大长度为2^{16}-1=65535字节$
		+ 但是,数据链路层规定了帧的数据字段的最大长度,MTU,
		因而IP数据报的长度也受到MTU的限制,不能超过
		+ ...????512,,,???
		+ 分片的数据报的这个字段指的是本片首部+数据长度
	- **标识**(identification),IP软件在存储器中维持一个计数器,每产生一个数据报,
	计数器就加1,并将此值赋给标识字段
		+ 这个字段不是序号,因为IP层提供的是无连接的服务,不存在编号这一说
		+ 当数据报由于长度超过网络的MTU的时候而需要分片时,
		<u>这个标识字段的值就复制到所有数据报片的标识字段</u>
			- 相同的标识字段使得分片后的数据报能正确的重装为原来的数据报
	- **标志**flag,只有两位有意义
	$flag字段最低位记为MF(morefragment),中间一位记为DF(Don`tFragment)$
		+ $MF=1,表示后面还有分片;MF=0,表示这已是若干数据报片张的最后一个$
		+ $DF=0时,才允许分片$
	- **片偏移**,片偏移指出:本片在原分组中的相对位置,相对于用户数据字段的起点,该片从何处开始
	**以8个字节为单位**
		+ 则每个分片的长度一定是8字节/64位的整数倍
	- **生存时间**TTL(time to live ):表明数据报在网络中的寿命,
	由发出站设置这个字段,目的是<u>防止无法交付的数据报无限制地在因特网中兜圈子</u>
		+ 最初,以秒为单位
		+ 跳数限制,单位:跳数
		TTL指明数据报在因特网中最多可经过多少个路由器
		TTL减小到0,就丢弃数据报,不再转发
			- **字段长8位,*显然数据报最多经过255个路由器转发*
	- **协议**协议字段指出此数据报携带的数据使用何种协议,
	以便目的主机IP层知道应将数据部分上交给那个处理过程
		+ ![协议与对应字段][3]
	- **首部校验和** 这个字段只校验数据报的首部,不包括数据部分
	这是因为数据报每经过一个路由器,路由器都要重新计算一下首部校验和
	(因为一些字段如TTL,等都发生了变化,自然要重新计算,)不校验数据部分可以减少计算量
		+ 为了进一步减少计算量,IP首部的校验和不采用CRC,而是采用如下方法
		.....待补充....
	- 源地址,32位
	- 目的地址32位
+ 可变部分
可变部分是一个选项字段,用来支持排错,测量以及安全等措施
	- (因为可变部分很少使用)IPv6就把数据报的首部长度做成固定的

#####IP层转发分组的流程
路由表每一行对应于一个网络

每一跳路由最主要的是$以下两个信息\\\
(目的网络地址,下一条地址)$
其他的一些信息

+ 标志
	- U:路由可用
	- G:表示下一跳是一个路由器(因而是间接交付)
	- H:表示下一跳是一个主机(因而是直接交付)
+ 参考计数:给出正在使用改路由的TCP连接数
+ 使用情况:显示出通过该路由的分组数
+ 接口:本地接口的名字,指出应当从哪一个接口转发

分组一般是基于目的主机所在的网络(号)转发
**特定主机路由**:对特定的目的主机(号)指明一个路由
**默认路由**:
减少路由表所占用的空间和搜索花费的时间

<u>转发的数据报怎样找到下一跳路由,?</u>
路由器从路由表中查网络号/特定路由/默认路由,得到下一跳的IP地址后,
把IP数据报送交数据链路层的网络接口软件,
**网络接口软件使用ARP协议,根据下一跳的IP地址,找到下一跳路由的硬件地址**
把此硬件地址放在链路层的MAC帧的首部
把IP数据报放到数据链路层的MAC帧例,送到了下一跳路由器中

######分组转发算法

+ 从数据报的首部提出目的主机的IP地址D,得到网络地址N
+ 若N就是与此路由器直连的某个网络地址,则进行**直接交付**
(包括执行ARP协议,数据报封装成MAC帧,发送)
	- 否则就是间接交付,进入下一步(差特定主机路由)
+ 若路由表中有目的地址为D的*特定主机路由*,则把数据报送给指定的下一跳路由器
否则,进入下一步(从路由表中差网络地址)
+ 若路由表中有到达网络N的路由,则把数据报送给路由表中指明的下一跳路由器
否则,进入下一步(查默认路由)
+ 若路由表中有一个默认路由,则把数据报送给路由表中指明的默认路由器
否则,进入下一步
+ 报告转发分组出错

####3.划分子网和构造超网

#####划分子网
一个单位能随时灵活地增加本单位的网络,而不必实现到因特网管理机构去申请新的网络号

划分子网/子网寻址/子网路由选择
基本思路

+ 对外透明
+ 划分子网的方法是从网络的主机号$借用若干位作为子网号subnet-id,主机号的位数相应减少\\\
两级IP地址在本单位内部变成三级IP地址\\\
IP::={<net-id>,<subnet-id>,<host-id>}$
+ 凡是从其他网络发送给本单位的某个主机的IP数据报,仍然是根据IP数据报的目的网络号找到连接在
本单位网络的路由器.此路由器收到IP数据报后,**按目的网络号和子网号找到目的子网**
######子网掩码
<u>**子网的网络地址**</u>:网络号+子网号+主机位全为0
子网掩码用于路由器从目的IP地址中**提取**网络地址

子网掩码根据"网络号+子网号对应位为1,主机号位对应0"得出
IP地址与子网掩码按位相与就得到了网络地址
如果一个网络不划分子网,那么该网络的子网掩码就使用*默认子网掩码*

$子网号占用n位,则有2^n种可能排列$,
**全0和全1子网号的问题**,子网数目是否减2的问题
B类地址子网划分,子网号位数,取0,取1,取15,取16是没有意义的

划分子网增加了灵活性,但减少了能连接在网络上的主机总数

同一个IP地址,使用不同的子网掩码会得到不同的网络地址
同一个网络地址的写法,对应不同的子网掩码,得到的也是不同的网络地址

#####使用子网时的分组转发
子网划分之后,路由表必须包含**目的网络地址,子网掩码,下一跳地址**三项内容
子网划分之后,仅仅一个32位的目的网络地址并不能指明完整的网络号信息,必须加上子网掩码,
(才知道这个32位的数,网络号+子网号,取到哪一位(取到哪一个0)为止)

划分子网后的转发分组算法

1. 从数据报首部提取目的IP地址D
2. 判断是否**直接交付**:如何判断是否直接交付,?:
对路由器直连的网络逐个进行检查:用各网络的子网掩码和D逐位相与,看结果是否和相应的网络地址匹配
	- 若匹配,则进行直接交付(执行ARP,数据报封装成帧发送出去)
	- 若不匹配,则进入第三步
3. 判断是否**特定主机路由**
	- 若没有对应地址D的特定主机路由,则进入第四步
4. **查路由表**:具体如何查,?:
对路由表的每一行(网络地址,子网掩码,下一跳地址),用子网掩码和D逐位相与,得结果N,比对N与此行的网络地址
	- 若匹配,则按下一跳路由转发
	- 若查完所有行都没找到匹配,进入第五步
5. **查有无默认路由**
	- 若没有默认路由,则进入第六步
6. 报错
#####无分类编址CIDR(构成超网)
变长子网掩码Variable Length Subnet Mask VLSM
无分类域间路由选择Classless Inter-Domain Routing CIDR

CIDR特点

+ 消除传统的A,B,C类网络地址,以及划分子网的概念
$$IP::={<网路前缀>,<主机号>},无分类二级编址$$
	- 斜线记法
+ CIDR把网络前缀都相同的连续IP地址组成一个CIDR地址块
知道地址块中的任何一个地址,就知道了地址块的范围(最大地址,最小地址)

CIDR使用**地址掩码**(addreess mask)
(划分子网使用的叫做子网掩码)
斜线记法中,斜线后面的数字就是地址掩码中1的个数

**路由聚合/构成超网**route aggregation

构成超网:用CIDR表示的地址块有可能包含了多个分类的IP地址
CIDR的多种记法

+ 把点分十进制中,低位连续的0省略
	- $10.0.0.0/10 \rightarrow 10/10$
+ 在网络前缀后面加一个星号	

在分类地址的环境中,分配IP地址,相当于CIDR/8,/16,/24的情形,显然
CIDR分配IP地址更加灵活
######最长前缀匹配
使用CIDR的路由表中的项目:<网络前缀,下一跳地址>
最长前缀匹配/最佳匹配:查找路由表时,从匹配结果中选择具有最长网络前缀的路由
网络前缀越长,路由越具体
######使用二叉线索树查找路由表
唯一前缀
####4.网际控制报文协议ICMP
ICMP:为了更有效地转发数据报和提高交付成功的机会,在网络层使用网际控制报文协议
报文装在IP数据报中,作为数据部分,加上首部,组成IP数据报发送 出去
![IMCP][4]
#####ICMP报文种类
ICMP差错报告报文,ICMP询问报文
![ICMPTYPE][5]
代码字段是为了进一步区分某种类型中的几种不同情况

######ICMP差错报告报文

+ 终点不可达:路由器或主机不能交付数据报时,向源点发送终点不可达报文
+ 源点抑制:路由器或主机由于拥塞而丢弃数据报时,向源点发送源点抑制报文,是源点知道应该把数据报的发送速率放慢
+ 时间超时:
	- 路由器收到TTL为0的数据报时,除丢弃数据报之外,向源点发送时间超时报文
	- 当终点在预先规定的时间内不能收到一个数据报的全部数据报片时,向源点发送时间超时报文
+ 参数问题:收到的数据报首部中有字段的值不正确时,向源点发送参数问题报文
+ 改变路由(重定向):路由器向主机发送此报文,让主机知道下次将数据报发送给另外的路由器

**关于改变路由报文**
主机不和连接在网路上的路由器定期交换信息.
主机刚开始工作时,一般在路由表中设置一个默认路由器的IP.
不管数据报要发送到哪个目的IP,都一律将数据报传送给默认路由,默认路由知道到每一个目的网络的最佳路由
(因为路由之间交换了信息)
如果默认路由发现主机发往某个目的地址的数据报的最佳路由不应经过默认路由,就向主机发送这样一个报文
主机在自己的路由表中增加一个项目

ICMP的差错报告报文的数据字段
![ICMPDATA][6]
把收到的需要进行差错报告的IP数据报的前8个字节提取出来,作为ICMP报文的数据字段
(**是为了得到运输层的端口号,报文的发送序号**,这些信息对源点通知高层协议有用)
加上ICMP报文的前8个字节(类型,代码,检验和,ICMP类型)
就构成了ICMP差错报告报文
ICMP报文作为IP数据报的数据字段发送给源点

不发送ICMP差错报告报文的情况

+ 对ICMP差错报告报文不再发送ICMP差错报告报文
+ 对第一个分片的数据报片的所有后续片不再发送ICMP差错报告报文
+ 多播不发送
+ 特殊地址不发送(127.0.0.0,0.0.0.0)
######ICMP询问报文

+ 回送请求和回答
	- 用来测试目的站是否可达以及了解其有关状体
+ 时间戳请求和回答
	- 可以用来进行时钟同步和测量时间
#####ICMP应用举例
+ ping
ping,分组网间探测,packet Internet Grop
用来测试两个主机之间的连通性
使用ICMP的回送请求与回答报文
应用层直接使用网络层,额米有通过运输层的tcp/upd
+ tracert/traceroute
源主机向目的主机发送一连串的IP数据报
数据报中封装的是使用了非法端口因而无法交付的UDP用户数据报
	- $第一个数据报P_1的TTL设置为1$
		+ 路由器收到后将其TTL减一,因TTL变成零,路由器向源主机发送一个ICMP时间超时报文
	- 接着发送第二个数据报,TTL设置为2
	- ...
	- 这样一直继续下去,最后一个数据报成功到达了目的主机
	但是,因端口号非法,目的主机向源主机发送ICMP终点不可达差错报告报文
	- 这样源主机达到了自己的目的:**获知路由信息**
####5.因特网的路由选择协议
#####路由选择协议的几个基本概念
1. 理想的路由选择算法
	+ 特点
	+ **从路由算法能否随着网路的通信量或拓扑自适应地进行调整变化来划分**
		- 静态路由选择策略/非自适应路由选择
		- 动态路由选择策略/自适应路由选择
2. 分层次的路由选择协议
因特网采用的路由选择协议是**自适应/动态的,分布式路由选择协议**
因特网将整个互联网划分为许多较小的自治系统
	- 因特网把路由选择协议划分为两大类
		+ 内部网关协议(Interior Gateway Protocol)IGP:一个自治系统内部使用的路由协议
			- RIP
			- OSPF
		+ 外部网关协议(External Gateway Protocol)EGP:若源主机和目的主机在不同的自治系统中
			- BGP
	- 路由器运行,哪种协议的问题
#####内部网关协议RIP
IGP中的RIP
基于距离向量的距离路由选择协议
+ **每一个路由器维护它从自己到其他每一个目的网络的距离记录**
+ 距离/跳数(hop count):一路由器到直连的网络距离定义为1,从一路由器到非直连的网络定义为经过的路由器数加一
	- 允许一条路径最多只能包含15个路由器,因此距离等于16时,即相当于不可达
+ 不能在连个网络之间同时使用多条路由,总是选择距离最短的路由
(哪怕距离最短的路由不是速度最高的)

**路由交换信息三个要点**

+ 和哪些路由器交换信息
	- 仅和相邻的路由器交换信息
		+ 相邻:两个路由器之间的通信不需要经过另一个路由器
+ 交换什么信息
	- 当前本路由器知道的全部信息,即自己的路由表
	:"我到本自治系统中所有网络的最短距离,以及到么个网络应经过的下一跳路由器"
+ 什么时候交换信息
	- 按规定的时间间隔

######距离向量算法
原理:
$设X是A到B的最短路径上的一个结点.若把路径A\rightarrow B 拆成两段\\\
A\rightarrow X ,X \rightarrow B,则每一段路径A\rightarrow X ,X \rightarrow B也都分别是\\\
A到X,X到B的最短路径$
对每一个相邻路由器发送过来的RIP报文,进行以下步骤

1. 对地址为X的相邻路由器发送过来的RIP报文,先对此报文中的所有项目作如下修改
	+ 下一跳路由地址字段改为X,
	+ 距离字段加一
	+ 此时,每个项目有三个关键数据:$到目的网络N,距离为d,下一跳路由器为X$
2. 对修改后报文的每一个项目,如下操作
	+ 若原来的路由表中没有目的网络N的记录项,添加进去
	+ 否则(目的网络N已经在路由表中),则比较下一跳路由地址
		- 若原路由表中网络地址N的下一跳路由地址也是X,则用收到的报文替换掉
			+ 这叫项目更新了
		- 否则(下一跳路由地址不一样),则比较哪个距离小
			+ 若收到的项目中的距离较小,则更新
			+ 否则什么也不做
3. 若3分钟内还没有收到相邻路由器的更新路由表报文,则把此相邻路由器记为不可达的路由器
(即把距离置为16)
4. 返回

$改下一跳距离加一\rightarrow无则添加,同则更新;否则比较距离$

路由器不知道整个自治系统的拓扑,但是路由器拥有整个自治系统的全局路由信息
且**能保证每一个路由器到每一个目的网络的路由(距离字段)都是最短的**
具体到每个路由器,到同一个目的网络的距离,当然因各自位置不同而不同
######RIP协议报文格式
![RIPprotocol][7]
**RIP协议使用运输层的用户数据报UDP进行传送,PORT:520**

+ 命令字段:指出报文的意义
	- 1:请求路由信息
	- 2:对请求路由信息的响应或未被请求而发出的路由更新报文
+ 必为0:为了4字节对齐
+ 报文中的路由部分由若干个路由信息组成.
**每个路由信息用20个字节**
	- 地址标示符:标志使用的地址协议
		+ IP地址协议,则此字段值为2
	- 路由标记:填入自治系统号
		+ 考虑使RIP有可能受到本自治系统以外的路由选择信息
+ 一个RIP报文最多可包括25个路由
则RIP报文最大长度4+20x25=504Byte
+ RIP报文的鉴别功能

**RIP协议的缺点:好消息传播得快,坏消息传播得慢**

+ 坏消息传播的慢:相邻路由相互交换距离信息,彼此距离加到16才知道坏消息
	- 当网络出现故障时,要经过比较长的时间才能将此信息传送到所有的路由器
	- 可以采取的措施:记录信息接口,不再反向传送....
+ 好消息传播的块
	- 如果一个路由器发现了更短的路由,那么这种更新信息就传播得很快

实现简单,开销较小,适合规模较小的网络中
#####内部网关协议OSPF
IGP中的OSPF(open shortest path first)开放最短路径优先
open:协议公开发表
spf:使用了最短路径算法
使用分布式的链路状态协议
**OSPF的三个要点**

+ 和哪些路由器交换信息
	- 向本自治系统中的**所有路由器**发送信息
	(RIP是只向相邻路由器发送信息)
	- 使用**洪泛法**
		+ 相邻路由器不但接收信息,还向**所有&其他**路由器转发此信息
		达到了和所有路由器交换信息的目的
		(RIP协议中相邻路由器只接收信息,不转发)
+ 交换什么信息
	- 与本路由器相邻的所有路由器的链路状态,这只是路由器知道的部分信息
	(RIP交换自己知道的所有信息)
		+ 链路状态:本路由器和哪些路由器相邻,以及该链路的**度量/代价**
			- 度量:费用,距离,时延,带宽..
+ 什么时候交换信息
	- 只有**当链路状态发生变化时**
	(RIP定时交换信息)

由于各个路由器之间频繁地交换链路状态信息,因此
**所有的路由器最终都能建立一个链路状态数据库(全网的拓扑结构图)**
每一个路由器都知道全网共有多少个路由器,以及哪些路由器是相连的,代价多少
每一个路由器使用链路状态数据库中的数据根据Dijkstra的SPF算法,得到自己的路由表

OSFP将自治系统进一步划分为区域
*划分区域的好处是把利用洪泛法交换链路状态信息的范围局限于每一个区域,减少了网络上的通信量*
层次结构的区域划分
区域边界路由器
主干路由器
自治系统边界路由器
######OSFP的报文格式
![OSPFprotocol][8]
**OSPF协议直接使用IP数据报传送(IP数据报首部协议字段值89)**
24字节的固定长度首部,报文分钟5种类型

+ 版本:当前是2
+ 类型:5种中的任一种
+ 分组长度:包括首部在内的整个分组的长度,以字节为单位
+ 路由器标识符:标志发送该分组的路由器的接口的IP地址
+ 区域标识符:分组属于的区域的标识符
+ 检验和
+ 鉴别类型:0不用口令,1用口令
+ 鉴别
	- 鉴别类型为0时,即不用口令/不鉴别时,填入0
	- 鉴别类型为1时,填入64位/8个字节/8个字符的口令
OSPF的其他特点

+ 允许管理员给每条路由指派不同的代价
+ 如果到同一个目的网络有多条代价相同的路径,那么可以将通信量分配给这几条路径:**负载均衡**
+ 所有在OSPF路由器之间交换的分组具有鉴别功能,可以保证只在信赖的路由器之间交换链路状态信息
+ OSPF支持VLSM和CIDR
+ OSPF让每一个链路都带上一个32位的序号....?
######OSPF的五种分组类型

+ 类型1,问候分组
	- 用来发现和维持邻站的可达性
	- 相邻路由器每隔10s交换一次问候分组
+ 类型2,数据库描述分组
	- 向邻站给出自己的链路状态数据库中所有链路状态项目的摘要信息
+ 类型3,链路状态请求分组
	- 向对方请求发送某些链路状态项目的详细信息
+ 类型4,链路状态更新分组
	- 用洪泛法对全网更新链路状态
+ 类型5,链路状态确认分组
	- 对链路状态更新分组的确认
+ 类型2-5用于进行链路状态数据库的同步
同步:不同路由器的链路状态数据库的内容是一样的

OSPF并非将自己的本地链路状态信息对全网进行广播,而是采用如下方法
用**类型2的数据库描述分组**发送摘要信息,
其他路由器按需请求,发送**类型3的链路状态请求分组**
本路由器收到请求后发送**类型4的链路状态更新分组**
其他路由器收到更新分组后再回送**类型5的链路状态确认分组**

指定的路由器
#####外部网关协议BGP
EGP中的BGP边界网关协议

+ 因特网的规模太大,使得AS之间路由选择非常困难
+ AS之间的路由选择必须考虑有关策略

BGP只力求寻找一条能够到达目的网络的比较好(不兜圈子)的路由,而并非要寻找一条最佳路由
BGP采用路径向量路由选择协议
BGP发言人/BGP边界路由器
一个BGP发言人与其他AS的BGP要交换路由信息,就要先建立TCP连接(port179)
在此连接上交换BGP报文以建立BGP会话
使用TCP连接交换路由信息的两个BGP发言人彼此成为对方的邻站
**交换网络可达性信息**:要到达某个网络(用网络前缀,表示)所要经过的一系列自治系统
$要到达网络N_1,N_2,N_3...可沿路径(AS_1,AS_2..)$
BGP发言人通过检查自己是否在收到了路径中,来避免兜圈子

BGP的四种报文

+ 打开OPEN报文
	- 用来与相邻的另一个发言人建立关系,通信初始化
	- 若两个邻站属于两个不同的AS,
	而其中一个邻站打算和另一个邻站定期地交换路由信息
	这就**应当有一个商谈的过程**(因为可能一方不愿交换)
	为了商谈,一开始,发送OPEN报文
	- 6个字段
		+ 版本
		+ 本自治系统号ASN		
		+ 保持时间
		+ BGP标识符:该路由器的IP地址
		+ 可选参数长度
		+ 可选参数
+ 保活KEEPLIVE报文
	- 周期性证实邻站的连通性	
	- 如果邻站接收这种邻站关系,就用KEEPLIVE报文响应
	由此,建立了邻站关系
	建立关系后,周期的发送KEEPLIVE报文来确信对方存在	
	- 只有19个字节,只用BGP报文的通用首部
+ 更新UPDATE报文:协议核心内容
	- 通告某一路由信息,以及列出要撤消的多条路由
	- 撤消路由一次可多条;增加路由一次一条
	- 5个字段
		+ 不可行路由长度:指明下一个字段的长度
		+ 撤销的路由:列出要撤消的路由
		+ 路径属性总长度:指明下一个字段的长度
		+ 路径属性
		+ NLRI网络层可达性信息:定义发出此报文的网络:网络前缀位数,IP地址前缀
+ 通知NOTIFICATION报文
	- 发送检测到的差错
	- 3个字段
		+ 差错代码
		+ 差错子代码
		+ 差错数据
![BGP报文格式][9]
四种类型的BGP报文具有同样的通用首部,长度为19字节

+ 标记:用于鉴别,不使用时,全1
+ 长度:最小值19
+ 类型:1-4对应四种报文
#####路由器的构成
多输入多输出端口的专用计算机
任务:转发分组
$$
\begin{equation}
	路由器结构
	\begin{cases}
		\text{路由选择}
		\begin{cases}
		路由选择协议\\\
		路由表\\\
		\end{cases}
		\\\
		\text{分组转发}
		\begin{cases}
		交换结构\\\
		输入端口\\\
		输出端口
		\end{cases}
	\end{cases}
\end{equation}
$$

+ 路由选择/控制部分
	- 核心构件:路由选择处理机
	- 任务
		+ 根据选定的路由选择协议构造出路由表
			- RIP协议:根据距离向量构造路由表
			- OSPF:根据链路状态构造路由表
			- BGP:根据路径向量构造路由表
		+ 和相邻路由器交换路由信息而不断更新和维护路由表
+ 分组转发
	- 交换结构:根据转发表对分组进行处理
		+ **转发表和路由表的区别**
			- 转发:根据转发表把收到的IP数据报从合适端口转发出去
			仅仅涉及一个路由器
			- 路由选择涉及多个路由器
			- 路由表包含从目的网络到下一跳(用IP地址)的映射
				+ 对网络拓扑变化的计算最优化
			- 转发表从路由表得出,包含完成转发功能所必须的信息
			从目的网络到输出端口和某些MAC地址信息(下一跳的以太网地址)的映射
				+ 对查找过程最优化
			- 实现的分离
			- 讨论路由选择原理时,可以不加区别
			具体到路由器构成时则有必要区别
		+ 三种常用的交换方法
			- 通过存储器
			- 通过总线
			- 通过互连网络
	- 输入端口:物理层->数据链路层->网络层
		+ 输入端口中的查找和转发功能在路由器的交换功能中是最重要的
		把复制的转发表放在每一个输入端口中:影子副本
		+ 输入排队
	- 输出端口:网络层->数据链路层->网络层
		+ 输出排队
####6.IP多播
多播靠路由器实现
路由器增加一些能够识别多播数据报的软件
由"主机发送多个单播"变为
主机发送一个多播数据报给路由器,由多播路由器复制分组
IP多播:在因特网上进行多播

+ 在多播数据报的目的地址中写入的是多播组的标识符
	- 多播标识符:D类IP地址
		+ 有一些不能用,因为已被指派为永久组地址
	- 协议字段:2,使用IGMP
	- 只用于目的地址,不能用于源地址
+ 让加入多播组的主机IP与多播标识符关联
#####在局域网进行硬件多播
D类IP地址与以太网多播地址的映射关系,
,???????????????
#####多播需要的协议
######IP多播需要两种协议
网际组管理协议IGMP,多播路由选择协议

+ 路由器如何知道多播组的成员
	- IGMP让连接在本地局域网上的多播路由器知道本局域网上
	是否有主机(的某个进程)参加或退出了某个多播组

**IGMP的本地使用范围**

多播路由选择协议比单播路由选择协议要复杂

+ 多播转发必须动态适应多播组成员的变化(这时网络拓扑可能并未发生变化)
	- 成员可能随时加入与退出
+ 多播转发不能仅仅根据多播数据报中的目的地址,还要考虑数据包的来自什么地方
	- 多播组以外的成员也要向多播组的成员发多播数据报
+ 多播数据报可以由没有加入的主机发出,可以通过没有组成员接入点网络
....
######IGMP
IGMP的工作分为两个阶段

+ 当某个主机加入新的多播组时,主机应向多播组的多播地址发送一个IGMP报文,声明自己要成为组成员
本地多播路由器收到IGMP报文后,还要利用多播路由选择协议把这种组成员关系转发给因特网上的其他多播路由器
+ 组成员关系是动态的
本地多播路由器要周期性地探询本地局域网上的主机,以便知道这些主机是否还继续是组成员
	- 只要有一个主机响应,那么多播路由器就认为这个组是活跃的
+ 具体措施
	- 在主机和多播路由器之间的通信都是使用IP多播
	- 多播路由器在探询成员关系时,只要对所以的组发送一个请求信息的询问报文,
	而不需要对每一个组发送一个询问报文
	- 当同一个网络上连接有几个多播路由器时,,,,?????????
	- 当主机同时参加几个多播组,对每一个多播组选择不同的随机数,来选择发送响应所需的时延
	- 同一个组内的每一个主机都要监听响应,只要有本组其他主机发送了响应,自己就不再发送响应

多播路由器向局域网上的组成员转发数据使用硬件多播
一个主机多个进程加入同一个多播,接收一个,主机向各个进程发送副本...,,???
,?????
######多播路由选择协议
多播路由选择:找出以源主机为根节点的多播转发树
在多播转发树上,每一个多播路由器向树的叶节点方向转发收到的多播数据报
对不同的多播组对应于不同的多播转发树
同一个多播组,对不同的源点有不同的多播转发树
,??????

转发多播数据报时使用的三种方法

+ 洪泛与剪除
+ 隧道技术
+ 基于核心的发现技术	
####7.VPN和NAT
#####虚拟专用网VPN
在一个机构内部的计算机通信也采用TCP/IP协议,那么
这些仅在机构内部使用的计算机就可以由本机构
**自行分配IP地址**
这些计算机使用仅在本机构有效的IP地址:本地地址
任意选择一些IP地址会引起麻烦,比如和因特网中的某个地址重合
因此,指明了一些**专用地址**用于作本地地址
因特网中的路由器,对目的地址是专用地址的数据报一律不转发



[0]:http://cjhgo.sinaapp.com/CS/ComputerNetwork/images/internetlayer.gif
[1]:http://cjhgo.sinaapp.com/CS/ComputerNetwork/images/ipclass.gif
[2]:http://cjhgo.sinaapp.com/CS/ComputerNetwork/images/IPpacket.gif
[3]:http://cjhgo.sinaapp.com/CS/ComputerNetwork/images/IPprotocol.png
[4]:http://cjhgo.sinaapp.com/CS/ComputerNetwork/images/ICMP.gif
[5]:http://cjhgo.sinaapp.com/CS/ComputerNetwork/images/ICMPtype.gif
[6]:http://cjhgo.sinaapp.com/CS/ComputerNetwork/images/ICMPdata.gif
[7]:http://cjhgo.sinaapp.com/CS/ComputerNetwork/images/RIPprotocol.gif
[8]:http://cjhgo.sinaapp.com/CS/ComputerNetwork/images/OSPFprotocol.gif
[9]:http://cjhgo.sinaapp.com/CS/ComputerNetwork/images/BGPprotocol.gif